# Barrobot version 0.005
"""
app.py – Flask UI for the Bar Robot

Key features
────────────
• Converts CocktailDB JSON dump (live_Recipes.json) → recipes.json,
  normalising all measures to ounces and scaling so the *smallest*
  non-zero measure becomes 1.5 oz.

• Menu shows only drinks you can make with:
    – Slots   (dispensed automatically)
    – Pantry  (manual add)
    – Substitutions (Jack Daniels → whisky, etc.)

• Two suggestion pages:
    /suggestions   – drinks missing *exactly* one ingredient
    /suggestions2  – drinks missing one or more (table view)

• Clickable thumbnail opens /drink/<id> with full recipe.

• Motor controls page lets you edit GPIO pins + jog to any slot instantly
  via /api/rotate/<slot>.

• Safe Mode toggle prevents GPIO output for dry-runs.

Dependencies: Flask, RPi.GPIO (mocked on non-Pi).

Directory layout (relative to this file):
static/
  └─ style.css
  └─ images/placeholder.png
templates/
  ├─ base.html
  ├─ menu.html
  ├─ drink.html
  ├─ suggestions.html
  ├─ suggestions2.html
  ├─ configure.html
  └─ motor_controls.html
live_Recipes.json  (CocktailDB dump) – optional, for first-time import
"""

from __future__ import annotations
from pathlib import Path
import json
import re
from typing import Any, Dict, List, Tuple

from flask import (
    Flask, render_template, request, redirect, url_for, flash, jsonify
)
import hardware  # your GPIO helper module

# ──────────────────
# Paths & constants
# ──────────────────
BASE_DIR     = Path(__file__).parent
CONFIG_PATH  = BASE_DIR / "config.json"
RECIPES_PATH = BASE_DIR / "recipes.json"

DEFAULT_PIN_MAP = {"DIR": 20, "STEP": 21, "ENABLE": 16, "ACTUATOR": 26}

app = Flask(__name__)
app.secret_key = "change-me-in-production"

# ──────────────────
# Helper functions
# ──────────────────
def _norm(txt: Any) -> Any:
    """Lower-case a non-blank string, else None."""
    return txt.strip().lower() if isinstance(txt, str) and txt.strip() else None


# --- Measure parsing & scaling ------------------------------------
_OZ_RX = re.compile(r"(?P<num>[\d.\/]+)\s*(?P<u>oz|ounce|ounces|ml|cl)?", re.I)

def _qty_to_oz(raw: str | None) -> float:
    """Convert '1/2 oz', '15 ml', '0.75' → fluid-ounces; default 1 oz."""
    if not raw:
        return 1.0
    m = _OZ_RX.search(raw)
    if not m:
        return 1.0
    num_txt, unit = m["num"], (m["u"] or "oz").lower()

    # Handle fractions like 1/2
    if "/" in num_txt:
        num = float(num_txt.split("/")[0]) / float(num_txt.split("/")[1])
    else:
        num = float(num_txt)

    # Unit conversion
    if unit == "ml":
        num *= 0.033814
    elif unit == "cl":
        num *= 0.33814
    return num


def _scale_ingredients(ings: List[Tuple[str, float]]) -> List[Tuple[str, float]]:
    """Return new list where min non-zero qty == 1.5 oz (rounded 0.02)."""
    non_zero = [q for _, q in ings if q > 0]
    if not non_zero:
        return ings
    factor = 1.5 / min(non_zero)
    return [(item, round(q * factor, 2)) for item, q in ings]


# --- Config I/O ----------------------------------------------------
def load_config() -> Dict[str, Any]:
    cfg = json.loads(CONFIG_PATH.read_text()) if CONFIG_PATH.exists() else {}
    cfg.setdefault("slots", [None] * 12)
    cfg.setdefault("pantry", [])
    cfg.setdefault("substitutions", {})
    cfg.setdefault("safe_mode", True)
    cfg.setdefault("pins", DEFAULT_PIN_MAP.copy())

    cfg["slots"]         = [_norm(s) for s in cfg["slots"]]
    cfg["pantry"]        = [_norm(p) for p in cfg["pantry"] if _norm(p)]
    cfg["substitutions"] = {k.lower(): v.lower()
                            for k, v in cfg["substitutions"].items()}
    return cfg


def save_config(cfg: Dict[str, Any]) -> None:
    CONFIG_PATH.write_text(json.dumps(cfg, indent=2))


# --- Recipe import & cache ----------------------------------------
def _import_and_scale(api_obj: Dict[str, Any]) -> Dict[str, Any]:
    """Convert CocktailDB drink → internal scaled format."""
    name        = api_obj["strDrink"]
    drink_id    = api_obj["idDrink"]
    instructions= api_obj["strInstructions"]
    image       = api_obj["strDrinkThumb"]

    raw_ings: List[Tuple[str, float]] = []
    for i in range(1, 16):
        ing = api_obj.get(f"strIngredient{i}")
        if ing and ing.strip():
            qty = _qty_to_oz(api_obj.get(f"strMeasure{i}"))
            raw_ings.append((_norm(ing), qty))

    scaled = _scale_ingredients(raw_ings)

    return {
        "id": drink_id,
        "name": name,
        "image": image,
        "instructions": instructions,
        "ingredients": [{"item": item, "qty_oz": qty} for item, qty in scaled],
    }


def load_recipes() -> List[Dict[str, Any]]:
    """Load cached recipes.json; build from live_Recipes.json on first run."""
    if RECIPES_PATH.exists():
        return json.loads(RECIPES_PATH.read_text())

    api_path = BASE_DIR / "live_Recipes.json"
    if not api_path.exists():
        return []

    raw = json.loads(api_path.read_text())
    drinks = raw["drinks"]
    processed = [_import_and_scale(d) for d in drinks]
    RECIPES_PATH.write_text(json.dumps(processed, indent=2))
    return processed


def parse_ingredients(rec: Dict[str, Any]) -> List[Tuple[str, float]]:
    """Return [(item, qty_oz)] accepting both new and legacy formats."""
    out: List[Tuple[str, float]] = []
    for raw in rec["ingredients"]:
        if isinstance(raw, str):               # legacy string list
            out.append((raw.lower(), 1.0))
        elif isinstance(raw, dict):
            out.append((raw["item"], float(raw.get("qty_oz", 1))))
        else:
            raise TypeError(f"Bad ingredient {raw!r}")
    return out


# --- Availability helpers -----------------------------------------
def _is_available(item: str, cfg: Dict[str, Any]) -> bool:
    item = item.lower()
    if item in cfg["slots"] or item in cfg["pantry"]:
        return True
    sub = cfg["substitutions"].get(item)
    return bool(sub and (sub in cfg["slots"] or sub in cfg["pantry"]))


def _resolve_slot(item: str, cfg: Dict[str, Any]) -> int | None:
    item = item.lower()
    if item in cfg["slots"]:
        return cfg["slots"].index(item)
    sub = cfg["substitutions"].get(item)
    if sub and sub in cfg["slots"]:
        return cfg["slots"].index(sub)
    return None


# ──────────────────
# Routes – UI pages
# ──────────────────
@app.route("/")
def menu():
    cfg = load_config()
    drinks = [
        d for d in load_recipes()
        if all(_is_available(item, cfg) for item, _ in parse_ingredients(d))
    ]
    return render_template("menu.html", drinks=drinks)


@app.route("/drink/<drink_id>")
def drink_detail(drink_id: str):
    drink = next((d for d in load_recipes() if d["id"] == drink_id), None)
    if not drink:
        flash("Drink not found.", "error")
        return redirect(url_for("menu"))
    return render_template("drink.html", drink=drink)


@app.route("/suggestions")
def suggestions():
    """Drinks missing exactly ONE ingredient."""
    cfg = load_config()
    ideas = []
    for r in load_recipes():
        missing = [item
                   for item, _ in parse_ingredients(r)
                   if not _is_available(item, cfg)]
        if len(missing) == 1:
            ideas.append({"recipe": r, "missing": missing[0]})
    return render_template("suggestions.html", ideas=ideas)


@app.route("/suggestions2")
def suggestions2():
    """Table of drinks missing 1+ ingredients."""
    cfg = load_config()
    ideas = []
    for r in load_recipes():
        missing = [item
                   for item, _ in parse_ingredients(r)
                   if not _is_available(item, cfg)]
        if missing:
            ideas.append({"recipe": r, "missing": missing})
    return render_template("suggestions2.html", ideas=ideas)


@app.route("/configure", methods=["GET", "POST"])
def configure():
    cfg = load_config()

    if request.method == "POST":
        cfg["slots"] = [_norm(request.form.get(f"slot{i}")) for i in range(12)]

        cfg["pantry"] = [_norm(p) for p in
                         (request.form.get("pantry") or "").split(",")
                         if _norm(p)]

        subs: Dict[str, str] = {}
        for n in range(6):
            k = _norm(request.form.get(f"sub_key{n}"))
            v = _norm(request.form.get(f"sub_val{n}"))
            if k and v:
                subs[k] = v
        cfg["substitutions"] = subs

        cfg["safe_mode"] = bool(request.form.get("safe_mode"))
        save_config(cfg)
        flash("Configuration saved.", "success")
        return redirect(url_for("menu"))

    return render_template("configure.html", bottle_config=cfg)


@app.route("/motor", methods=["GET", "POST"])
def motor_controls():
    cfg = load_config()

    if request.method == "POST":
        cfg["pins"] = {sig: int(request.form[sig])
                       for sig in ("DIR", "STEP", "ENABLE", "ACTUATOR")}
        save_config(cfg)
        hardware.set_pin_map(cfg["pins"])
        flash("Pin map saved.", "success")
        return redirect(url_for("menu"))

    return render_template("motor_controls.html", pins=cfg["pins"])


# ───── JSON API for test rotation ─────
@app.route("/api/rotate/<int:slot>", methods=["POST"])
def api_rotate(slot: int):
    if not 1 <= slot <= 12:
        return jsonify(status="error", msg="slot out of range"), 400
    cfg = load_config()
    hardware.set_pin_map(cfg["pins"])
    hardware.set_safe_mode(cfg["safe_mode"])
    hardware.rotate_to_slot(slot - 1)
    return jsonify(status="ok")


# ───── Make-drink route ─────
@app.route("/make_drink/<name>")
def make_drink(name: str):
    cfg = load_config()
    hardware.set_pin_map(cfg["pins"])
    hardware.set_safe_mode(cfg["safe_mode"])

    recipe = next((r for r in load_recipes()
                   if r["name"].lower() == name.lower()), None)
    if recipe is None:
        flash(f"No recipe named “{name}”.", "error")
        return redirect(url_for("menu"))

    for idx, (item, qty) in enumerate(parse_ingredients(recipe)):
        if not _is_available(item, cfg):
            flash(f"Missing “{item}”!", "error")
            return redirect(url_for("menu"))

        slot = _resolve_slot(item, cfg)

        if idx == 0:
            flash(f"Pulling the {item} out of the top shelf…", "info")
        else:
            flash(f"Adding a splash of {item}…", "info")

        if slot is not None:
            hardware.rotate_to_slot(slot)
            flash(f"Dispensing {qty:g} oz of {item}!", "info")
            hardware.press_actuator(repetitions=round(qty))
        else:
            flash(f"(Pantry) add {qty:g} oz of {item} manually.", "info")

    flash(f"{recipe['name']} is ready—cheers!", "success")
    return redirect(url_for("menu"))


# ──────────────────
# Run (dev only)
# ──────────────────
if __name__ == "__main__":
    cfg0 = load_config()
    hardware.set_pin_map(cfg0["pins"])
    hardware.set_safe_mode(cfg0["safe_mode"])
    try:
        app.run(host="0.0.0.0", port=5000, debug=True)
    finally:
        hardware.cleanup()

